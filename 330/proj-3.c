// Luis Guillermo Niebla Rios

#include "sem.h"

struct TCB_t * RunQ;
struct TCB_t * touchedHistory;
#define DEBUG 0 
ucontext_t uctx_main;
ucontext_t parent;
struct sem * empty;
struct sem * full;
struct sem * mutex;
int buffer;
struct TCB_t * tcb_buff;
int buff[5];
int fill = 0;
int use = 0;

void put(int value) {
    // if (buff[fill] != 0){
    //     printf("=====ERROR PRODUCED AT NON A NULL VALUE=====\n");
    //     sleep(3);
    // }
    struct TCB_t * thisRecord = NewItem();
    thisRecord->identifier = RunQ->next->identifier;
    AddToEnd(touchedHistory, thisRecord);
    // printf("Touched history\n");
    // PrintQueue(touchedHistory);
    // buff[fill] = value;
    
    // fill = (fill + 1) % 6;
}

TCB_t * get() {
    // int tmp = buff[use];
    // if (tmp == 0) {
    //     printf("=======ERROR AT A NON NULL VALUE=====\n");
    //     sleep(4);
    // }
    // printf("Deleting touched history");
    // PrintQueue(touchedHistory);
    TCB_t *head = DelQueue(touchedHistory);
    // printf("Deleting touched history resulted in\n");
    // PrintQueue(head);
    return head;
    // buff[use] = 0;
    // use = (use + 1) % 6;
    // return tmp;
}

int out;

int item;
int last_touched = 0;



void producer_1() {
    int in = 1;
    while(1) {
        // printf("==This is Producer 1\n");
        P(empty);
        P(mutex);
        put(in++);
        // printf("This is %s producing item number %d\n", RunQ->next->identifier, in - 1);
        //  printf("This is %s producing item number %d\n", RunQ->next->identifier, in - 1);
        // printf("out: %d %d %d %d %d %d\n", buff[0], buff[1], buff[2], buff[3], buff[4], buff[5]);
        V(mutex);
        V(full);
        
        printf("This is %s producing item number %d\n", RunQ->next->identifier, in - 1);
        yield();
    }
}

void consumer_1() {
    while(1) {
        P(full);
        P(mutex);
        TCB_t * tmp =  get();
        // printf("This is %s consuming %d\n", RunQ->next->identifier, tmp);
        // printf("out: %d %d %d %d %d %d\n", buff[0], buff[1], buff[2], buff[3], buff[4], buff[5]);

        // printf("This is %s consuming item generated by %s\n", RunQ->next->identifier, tmp->identifier);
        V(mutex);
        V(empty);
        printf("This is %s consuming item generated by %s\n", RunQ->next->identifier, tmp->identifier);
        yield();
    }
}

void generate_threads(void (*function) (void), int payload, char * str, int threads) 
{
    
}
int main() {
    tcb_buff = NewItem();
    out = 0;
    touchedHistory = NewItem();
    touchedHistory->payload = 0;
    empty = (struct sem *) malloc(sizeof(struct sem));
    mutex = (struct sem *) malloc(sizeof(struct sem));
    full = (struct sem *) malloc(sizeof(struct sem));
    InitSem(empty, 6, "empty");
    empty->queue = NewItem();
    InitSem(mutex, 1, "mutex");
    mutex->queue = NewItem();
    InitSem(full, 0, "full");
    full->queue = NewItem();
    RunQ = NewItem();
    RunQ->payload = 0;

    start_thread(consumer_1, 1, "Consumer 1");
    start_thread(consumer_1, 2, "Consumer 2");
    start_thread(consumer_1, 3, "Consumer 3");
    start_thread(producer_1, 1, "Producer 1");
    start_thread(producer_1, 2, "Producer 2");
    start_thread(producer_1, 3, "Producer 3");
    start_thread(producer_1, 4, "Producer 4");
    start_thread(producer_1, 5, "Producer 5");
    start_thread(producer_1, 6, "Producer 6");
    start_thread(producer_1, 7, "Producer 7");
    start_thread(consumer_1, 4, "Consumer 4");
    start_thread(consumer_1, 5, "Consumer 5");
    start_thread(consumer_1, 6, "Consumer 6");
    start_thread(consumer_1, 7, "Consumer 7");
    start_thread(consumer_1, 8, "Consumer 8");
    start_thread(consumer_1, 9, "Consumer 9");
    start_thread(consumer_1, 10, "Consumer 10");
    start_thread(producer_1, 8, "Producer 8");
    start_thread(producer_1, 9, "Producer 9");
    start_thread(producer_1, 10, "Producer 10");
    
    // PrintQueue(RunQ);
    // sleep(1);
    run();
}