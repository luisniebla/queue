#include "sem.h"

struct TCB_t * RunQ;
struct TCB_t * touchedHistory;

ucontext_t uctx_main;
ucontext_t parent;
struct sem * empty;
struct sem * full;
struct sem * mutex;
int buffer;
int buff[5];
int out;
int in;
int item;
int last_touched = 0;



void producer_1() {
    while(1) {
        P(empty);
        P(mutex);
        buff[in] = 1;
        in = (in + 1) % 5;
        V(mutex);
        V(full);
        printf("Producer adding item to record\n");
        struct TCB_t * thisRecord = NewItem();
        thisRecord->payload = 1;
        AddQueue(touchedHistory, thisRecord);
        PrintQueue(touchedHistory);
        printf("---Finished with producer---\n");
    }
}

void consumer_1() {
    while(1) {
        printf("Entering Consumer\n");
        P(full);
        P(mutex);
        item = buff[out];
        out = (out + 1) % 5;
        V(mutex);
        printf("Mutex is free\n");
        printf(empty);
        V(empty);
        printf("Empty is free\n");
        printf(empty->value);
        // buffer--;
        struct TCB_t * lastTouch = DelQueue(touchedHistory);
        if (lastTouch) {
            printf("This is consumer %d consuming item generated by producer %d\n", 1, lastTouch->payload);
        }else{
            printf("Consumer %d is waiting\n", 1);
        }
        printf("---Finished with Consumer---\n");
    }
}

int main() {
    printf("==============");
    out = 0;
    in = 0;
    touchedHistory = NewItem();
    touchedHistory->payload = 0;
    empty = (struct sem *) malloc(sizeof(struct sem));
    mutex = (struct sem *) malloc(sizeof(struct sem));
    full = (struct sem *) malloc(sizeof(struct sem));
    InitSem(empty, 1);
    InitSem(mutex, 1);
    InitSem(full, 6);
    RunQ = NewItem();
    RunQ->payload = 0;
    start_thread(consumer_1, 1);
    start_thread(producer_1, 2);
    getcontext(&parent);
    run();

}